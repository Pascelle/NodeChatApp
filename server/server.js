//this is the root of our node application.  It creates a new express app, configures the public directory to be the static folder that express serves up, and it calls app.listen to start up the server

//we want to configure the server to serve up the public directory.  we are going to use a built-in node module that makes it easy to convert paths, since server.js is far away from index.html.  It also matters because of cross-compatibility with different OSes.  The module is called path

//Behind the scenes Express is actually using a built in node module called HTTP to create the server.  We need to use HTTP, configure Express to work with HTTP and only then can we add socket.io support

//when we integrated socket.io with our server we got access to a route that accepts incoming connections (so we can use socket.io) and we got access to a JS library that makes it easy to work with socket.io on the client (localhost:3000/socket.io/socket.io.js)


const path = require('path');
const http = require('http');
const express = require('express');
//Express makes it easy to set up an HTTP server
const socketIO = require('socket.io');

const {generateMessage, generateLocationMessage} = require('./utils/message');
const {isRealString} = require('./utils/validation');
const {Users} = require('./utils/users');

const publicPath = path.join(__dirname, '../public');
//takes two arguments: directory name (here it is server), the relative path (up one to node-chat-app) and folder you go into (here it is public)

const port = process.env.PORT || 3000;
//for heroku
var app = express();
//Above: Express is used to set up an http server.  
//Above: you do not use express by passing in arguments, instead you use it by calling methods on app

//below: create server using HTTP library
var server = http.createServer(app);
//Express and HTTP are so integrated you can just use app as the argument.  Now we're using the HTTP server as opposed to the express server. So below it is now server.listen instead of app.listen

var io = socketIO(server);
//we get back our web sockets server.  On there we can emit or listen to events.  this is how we faciliate communication between client and server

/*/ The newMessage event is generated by the server and emitted to the client.  The createMessage event is generated by the client and emitted to the server /*/

var users = new Users();
//creating an instance of Users like that found over in users.js.  It's a class so we have access to all of the methods created for that class

app.use(express.static(publicPath));
//this configures our express static middleware that serves up the public folder

io.on('connection', (socket) => {
	console.log('new user connected');
		//this lets you register an event listener.  This lets you listen for a connection to the server and when that connection comes in it deploys the callback fcn.  The socket argument represents the individual socket as opposed to all the users connected to the server.

	

	socket.on('createMessage', (message, callback) => {
		//listening for client to create message, when they do, callback called w/ message object containing data from client
		var user = users.getUser(socket.id);
		//remember we create an instance of the Users class and stored it in var users up above
		//getUser created over in user.js
		//this retrieves the name of the user


		if (user && isRealString(message.text)) {
			io.to(user.room).emit('newMessage', generateMessage(user.name, message.text)); 
			// 	when createMessage happens over on the client, a newMessage is created by the server containing some of the data from the client
			//user.room is the room that the current user is in
		}



		
		callback();
			//this is the other half of the event acknowledgment.  Callback () sends an event back to the front end and it is going to call the fcn as we have it here (which is the console.log over in index.js).  If we want we can pass a string into that function and it would make it over to the index.js fcn.  This means we can create a var for the argument value over in index.js, let's say we call it data, and print it to the screen via console.log 
			//Server acknolwedges that it got the data by calling callback
	});


	//this sets up the 'join' listener for server.js
	socket.on('join', (params, callback) => {
		//first validate the info that came in params--- are they empty strings or nonstring type?  Put this in utils/validation.js.  If they are not real string then we call the callback passing in the error
		if (!isRealString(params.name) || !isRealString(params.room)) {
			return callback('Name and room name are required');
			//by returning we make sure none of the addUser code runs if the data is not valid
		}
		//we can choose to connect to everyone on the server or just people in specific rooms via emmitting chat messages to desired people. socket.join.  Params.room will be the value entered during login
		//socket.leave kicks you out of the group.  How to target specific users? io.to('thenameoftheroom').emit or socket.broadcast.to('thenameiftheroom').emit (sends to everyone but the sender)

		socket.join(params.room);
		users.removeUser(socket.id);
		//checks to see if that id is in any other room. if so it removes user from other room
		users.addUser(socket.id, params.name, params.room);
		//add a user to the "people" list when they join a new room
		io.to(params.room).emit('updateUserList', users.getUserList(params.room));
		//this updates everyone on who is currently in the room
		socket.emit('newMessage', generateMessage('Admin', 'Welcome to the chat app'));
		//the above sends a greeting to a user that joins the chat
		//message.js in the utils folder contains a method to create the message object

		socket.broadcast.to(params.room).emit('newMessage', generateMessage('Admin', `${params.name} has joined`));
		//socket.broadcast.emit sends a message that there is a new user to everyone but the sender
		//socket.emit emits an event to a single connection, io.emit emits an event to all connections
		//TO BROADCAST: specify the individual socket that we don't want to get the event. socket.broadcast.emit() gets sent to everybody but the socket object originating the broadcast


		callback();
		//if both are strings we still want to call callback but not pass anything in because the socket.emit 'join' fcn over in chat.js that receives the parameter receives it as an error

	});

	socket.on('createLocationMessage', (coords) => {
		var user = users.getUser(socket.id);
		//users object created from the User class. fetching user by the id, which is stored in socket. 
		//we know user has access to a room property (used below) because when it was created with the addUser function over in users.js it was given three arguments: id, name, room

		if (user) {
		io.to(user.room).emit('newLocationMessage', generateLocationMessage(user.name, coords.latitude, coords.longitude));
		//we email the newLocationMessage along with the object we defined in message.js
		}
	});

	socket.on('disconnect', () => {
		var user = users.removeUser(socket.id);

		if (user) {
			io.to(user.room).emit('updateUserList', users.getUserList(user.room));
			//gets rid of the users that have left the room
			io.to(user.room).emit('newMessage', generateMessage('Admin', `${user.name} has left.`));

		}
	});

});

server.listen(port, () => {
	console.log(`Server is up on port ${port}`);
});

