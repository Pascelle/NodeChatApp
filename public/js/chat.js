//this will contain all the JS we need to make index.html work

//below: what .emit does is create a client side script that connects to the server and as soon as it connects it emits this createMessage event

//below: this script loads a method that allows us to initiate a connection request 

var socket = io();
//available to us bc we loaded in socket.io.  When we call it we are innitiating the request from the client to the server to open up a web socket and keep that connection open.   What we gets back from io() is important and should be stored in a var.  var socket allows us to listen for data from the server and send data to the server.

function scrollToBottom () {
	// Selectors
	var messages = $('#messages');
	//Heights
	var newMessage = messages.children('li:last-child');
	//children() lets you write a selector specific to the children of the message. ex/ maybe we want select the li that are the last child
	var clientHeight = messages.prop('clientHeight');
	var scrollTop = messages.prop('scrollTop');
	var scrollHeight = messages.prop('scrollHeight');
	//the prop method is a cross browser way to fetch a property, this is a jquery alternative way of getting the property regardless of what the bowser actually calls the property
	var newMessageHeight = newMessage.innerHeight();
	var lastMessageHeight = newMessage.prev().innerHeight();
	//prev moves us to the previous child, so if we were just int eh last child we will be in the second to last child

	if (clientHeight + scrollTop + newMessageHeight + lastMessageHeight >= scrollHeight) {
		messages.scrollTop(scrollHeight);
		//jquery method for setting the scrollTop value
		console.log('Should scroll');
	}
}
//the purpose of this is to scroll down every time a new message comes in

/*/ The newMessage event is generated by the server and emitted to the client.  The createMessage event is generated by the client and emitted to the server /*/

socket.on('connect', function () {
	//we don't get a socket argument here bc we already have it above
	var params = jQuery.deparam(window.location.search);
	socket.emit('join', params, function (err) {
		if (err) {
			alert(err); //maybe you can pass in a modal using bootstrap to pop up the error
			window.location.href = '/';
			//we can manipulate what page the user is on.  Here we are redirecting them onto the root page
		} else {
			console.log('no error')
		};
	});
	//arguments: event name, params object, acknowledgements if someone does or doesn't join the room (doesn't join probably gave invalid data)

	//this is going to start the process of having separate chat rooms, although server.js does the heavy lifting.  It's a custom emit event.  When the server hears the join event it is going to go through the process of setting up the room
});

socket.on('disconnect', function () {
	console.log('disconnected from server');
});

// socket.on('newEmail', function (email) {
// 	//the data sent as the second argument to the emit call over in server.js is the argument here, then we can do what we want with it-- like add it to a list of emails
// 	console.log('New email', email);
// });

socket.on('updateUserList', function (users) {
	var ol = $('<ol></ol>');

	users.forEach(function (user) {
		ol.append($('<li></li>').text(user));
	});
	$('#users').html(ol);
	//we're using html as opposed to append bc we want to completely wipe the list, replacing it with the new version
});

socket.on('newMessage', function (message) {
	var formattedTime = moment(message.CreatedAt).format('h:mm a');
	var template = $('#message-template').html();
	//html method returns the markup inside of message-template. Message-template is inside of index.html
	var html = Mustache.render(template, {
		text: message.text,
		from: message.from,
		createdAt: formattedTime
	});
	//takes the template you want to render it and then you can spit it out in the browser by adding it to the message's ID
	//the second argument is an object that lists all of the properties that you are allowed to render
	//the template serves as the reusable structure but the data will change bc it gets passed in when we call render

	$('#messages').append(html);
	scrollToBottom();
		/*/ COMMENTED OUT IN FAVOR OF MUSTACHE.HS /*/
		// var formattedTime = moment(message.CreatedAt).format('h:mm a');

		// var li = $('<li></li>');
		// li.text(`${message.from} ${formattedTime}: ${message.text}`);

		// $('#messages').append(li);	

});

socket.on('newLocationMessage', function (message) {
	// var li = $('<li></li>');
	// var a = $('<a target="_blank">My current location</a>');

	var template = $('#location-message-template').html();
	var formattedTime = moment(message.CreatedAt).format('h:mm a');

		var html = Mustache.render(template, {
		url: message.url,
		from: message.from,
		createdAt: formattedTime
	});

	$('#messages').append(html);
	scrollToBottom();
		// li.text(`${message.from} ${formattedTime}: `);
		// a.attr('href', message.url);
		// //updating anchor tag.  you can set and fetch attributes on your jquery selected elements using this method.  If you provide one argument, like target, it fetches the value in which case it would return the "_blank", if you provide two arguments it sets the value
		// li.append(a);
		// $('#messages').append(li);
});

// //Below is one half of an event acknowledgement.  The other half is in server.js.  It is accomplished via the callback fcn
	// socket.emit('createMessage', {
	// 	from: 'Frank',
	// 	text: 'Hi'
	// }, function (data) {
	// 	//the callback from server.js was stored in the fcn.  We created a variable called data and then passed it into the console.log
// 		console.log('Got it', data);
	// }); 

var messageTextbox = $('[name=message]');

$('#message-form').on('submit', function (e) {
	//e is the event argument that we need to access in order to override the default behavior that causes the page refresh as soon as someone hits send.
	e.preventDefault();
	//now that we overrode the default behavior we call socket.emit
	socket.emit('createMessage', {
		from: 'User',
		text: messageTextbox.val()
		//jQuery [attribute=value] 
	}, function () {
		//the event acknowledgement.  awaits the callback from the server, but here we are going to wipe out the field
		messageTextbox.val('')
	});
});

var locationButton = $('#send-location');
locationButton.on('click', function () {
	//need to find out if user has access to geolocation API
	if (!navigator.geolocation) {
		return alert('Geolocation not supported by your browser');
	} //fetching a user's position.  Takes two arguments: success, failure

	locationButton.attr('disabled', 'disabled').text('Sending location...');
	//attr is a jquery method.  disable button to keep people from spamming

	navigator.geolocation.getCurrentPosition(function (position) {
		locationButton.removeAttr('disabled').text('Send location');
		//this is revive the location button after a position is fetched
		socket.emit('createLocationMessage', {
			latitude: position.coords.latitude,
			longitude: position.coords.longitude
		});

	}, function () {
		locationButton.removeAttr('disabled').text('Send location');
		alert('Unable to fetch location');
	});
});