//this will contain all the JS we need to make index.html work

//below: what .emit does is create a client side script that connects to the server and as soon as it connects it emits this createMessage event

//below: this script loads a method that allows us to initiate a connection request 

var socket = io();
//available to us bc we loaded in socket.io.  When we call it we are innitiating the request from the client to the server to open up a web socket and keep that connection open.   What we gets back from io() is important and should be stored in a var.  var socket allows us to listen for data from the server and send data to the server.


/*/ The newMessage event is generated by the server and emitted to the client.  The createMessage event is generated by the client and emitted to the server /*/


socket.on('connect', function () {
	//we don't get a socket argument here bc we already have it above
	console.log('Connected to server');

	
});

socket.on('disconnect', function () {
	console.log('disconnected from server');
});

// socket.on('newEmail', function (email) {
// 	//the data sent as the second argument to the emit call over in server.js is the argument here, then we can do what we want with it-- like add it to a list of emails
// 	console.log('New email', email);
// });

socket.on('newMessage', function (message) {
	var formattedTime = moment(message.CreatedAt).format('h:mm a');
	var template = $('#message-template').html();
	//html method returns the markup inside of message-template. Message-template is inside of index.html
	var html = Mustache.render(template, {
		text: message.text,
		from: message.from,
		createdAt: formattedTime
	});
	//takes the template you want to render it and then you can spit it out in the browser by adding it to the message's ID
	//the second argument is an object that lists all of the properties that you are allowed to render
	//the template serves as the reusable structure but the data will change bc it gets passed in when we call render

	$('#messages').append(html);
		
		/*/ COMMENTED OUT IN FAVOR OF MUSTACHE.HS /*/
		// var formattedTime = moment(message.CreatedAt).format('h:mm a');

		// var li = $('<li></li>');
		// li.text(`${message.from} ${formattedTime}: ${message.text}`);

		// $('#messages').append(li);	

});

socket.on('newLocationMessage', function (message) {
	// var li = $('<li></li>');
	// var a = $('<a target="_blank">My current location</a>');

	var template = $('#location-message-template').html();
	var formattedTime = moment(message.CreatedAt).format('h:mm a');

		var html = Mustache.render(template, {
		url: message.url,
		from: message.from,
		createdAt: formattedTime
	});

	$('#messages').append(html);

		// li.text(`${message.from} ${formattedTime}: `);
		// a.attr('href', message.url);
		// //updating anchor tag.  you can set and fetch attributes on your jquery selected elements using this method.  If you provide one argument, like target, it fetches the value in which case it would return the "_blank", if you provide two arguments it sets the value
		// li.append(a);
		// $('#messages').append(li);
});

// //Below is one half of an event acknowledgement.  The other half is in server.js.  It is accomplished via the callback fcn
	// socket.emit('createMessage', {
	// 	from: 'Frank',
	// 	text: 'Hi'
	// }, function (data) {
	// 	//the callback from server.js was stored in the fcn.  We created a variable called data and then passed it into the console.log
// 		console.log('Got it', data);
	// }); 

var messageTextbox = $('[name=message]');

$('#message-form').on('submit', function (e) {
	//e is the event argument that we need to access in order to override the default behavior that causes the page refresh as soon as someone hits send.
	e.preventDefault();
	//now that we overrode the default behavior we call socket.emit
	socket.emit('createMessage', {
		from: 'User',
		text: messageTextbox.val()
		//jQuery [attribute=value] 
	}, function () {
		//the event acknowledgement.  awaits the callback from the server, but here we are going to wipe out the field
		messageTextbox.val('')
	});
});

var locationButton = $('#send-location');
locationButton.on('click', function () {
	//need to find out if user has access to geolocation API
	if (!navigator.geolocation) {
		return alert('Geolocation not supported by your browser');
	} //fetching a user's position.  Takes two arguments: success, failure

	locationButton.attr('disabled', 'disabled').text('Sending location...');
	//attr is a jquery method.  disable button to keep people from spamming

	navigator.geolocation.getCurrentPosition(function (position) {
		locationButton.removeAttr('disabled').text('Send location');
		//this is revive the location button after a position is fetched
		socket.emit('createLocationMessage', {
			latitude: position.coords.latitude,
			longitude: position.coords.longitude
		});

	}, function () {
		locationButton.removeAttr('disabled').text('Send location');
		alert('Unable to fetch location');
	});
});